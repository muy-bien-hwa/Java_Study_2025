# 개념 정리


***


### Q. IntelliJ 에서 out 파일은 뭔가요?
### A.
✅ out 폴더는 .java 파일을 컴파일해서 만들어진 .class 파일들이 저장되는 곳이다.  
우리가 작성하는 것 → .java (소스 코드)  
자바가 실행하는 것 → .class (바이트코드)  
그 .class가 모이는 곳 → ✅ out 폴더

&nbsp;
***  


### ▶ IntelliJ에서 실행 시 일어나는 과정 
javac Main.java  →  Main.class 생성  →  out 폴더에 저장  →  실행  

&nbsp;
***


### ★ 클래스, 인스턴스, 객체 정리 
클래스 class = 설계도  
인스턴스 instance = 클래스를 new 명령문으로 메모리에 생성한 객체  
객체 object = 클래스가 전산화된, 속성과 행동으로 구성되어 있는 실체  
new 클래스명(); 를 통해 메모리에 객체를 생성 = 인스턴스화 하다.  

```java
class Test { ... }
new Test();
new Test();
new Test();
//     -> 메모리에 Test 클래스의 인스턴스를 3개 생성함.

Test t1 = new Test();
Test t2 = new Test();
Test t3 = new Test();
t1.abc();
t2.abc();
t3.abc();
// 위처럼 한 클래스로 여러 인스턴스 생성 가능.
```


### ▷ 객체와 인스턴스의 차이?  
  → 둘 다 비슷하지만, 더 정확하게는  
**객체(Object)** : 클래스에서 만들어진 대상   ( **개념적 표현** )  
**인스턴스(Instance)** : 메모리에 실제로 생성된 객체 ( **기술적 표현** )  
객체가 더 큰 개념이다? (X) 똑같은데 표현만 좀 다른거.  

*" new 명령어를 한 번 써서 클래스를 인스턴스화 하면 객체가 생성되고, 메모리에 인스턴스가 하나 생긴다. "*  


&nbsp;
---

### ▶ JVM이 사용하는 JAVA의 메모리 구조  

Code 영역 / Heap 영역 / Stack 영역  

**코드(Code) 영역**은 메서드 영역이라고도 함.  
메서드가 이 코드 영역에 저장됨.  
메서드를 불러오면 이 코드 영역에 이미 만들어진 메서드를 사용하는 것.  
자바 실행 파일이 실행되는 구조임.  
test.java(소스 파일) → test.class(실행 파일) → JVM [ Class loder → Byte code verifier → Interpreter → Runtime System ] → 운영 체제 & HW  
&nbsp;


**힙(Heap) 영역**은, new 명령문 실행 시 클래스의 인스턴스가 생성되는 메모리 부분.  
참고로 인스턴스의 메서드는 코드 실행 시 Class loder에 의해 이미 생성되기 때문에, 실제로 힙 영역에 저장되는 것은 인스턴스의 필드 값임.  
메서드는 코드 영역에 생성된 내용을 사용함.  

힙 영역에 필드가 생성되면 자동으로 필드는 초기화 됨.  
```java
// 필드 타입별 초깃값
byte = 0
short = 0
int = 0
long = 0L
float = 0.0F
double = 0.0D
char = '\u0000'
boolean = false
모든 참조변수 = NULL
```
&nbsp;  

**스택(Stack) 영역**은 메서드의 매개변수와 같은 지역변수를 저장하는 메모리 부분.  
```java
public int sum(int data1, int data2) {
  int result = data1 + data2;
  return result
}
```
위와 같은 코드가 있고, sum(10,20); 을 호출했다고 가정한다면 다음과 같이 작동함.  
1. sum() 메서드 본문이 실행되기 전에 data1, data2 매개변수가 스택 영역에 생성되고, 각각 10, 20이 저장됨.
2. 메서드 본문이 실행되면 int 타입의 result 지역변수가 스택에 생성되고, data1 + data2 값으로 초기화 됨.
3. result 값 리턴.

매개변수(지역변수)가 스택에 생성되는 시점 = **메서드가 호출되어 실행될 때**  
매개변수(지역변수)가 스택에서 삭제되는 시점 = **메서드가 종료될 때**  
**" 그렇기 때문에 매개변수는 메서드 내에서만 사용할 수 있다! "**  
&nbsp;  


자바 프로그램이 직접 접근할 수 있는 메모리는 오직 **스택 밖에 없음.**  
힙 영역에 있는 필드 값에 곧바로 접근할 수 없기 때문에, 스택 메모리에 참조변수를 선언하고 이 변수에 힙 메모리에 생성된 인스턴스의 위치 정보(참조 정보)를 저장함.  
즉, [ 자바 프로그램 -> 스택 메모리 내 참조변수 -> 힙 영역의 필드 값 ] 과 같이 접근.  

이게 명령문에서 어떤 식으로 나타나냐면,  
```java
클래스명 참조변수명 = new 클래스명();
// [데이터 타입 = (클래스명) 타입이다.] [스택 메모리에 생성될 참조변수의 이름]
// = [힙 메모리에 (클래스명) 인스턴스를 생성하고, 할당된 메모리의 위치 정보(참조 정보)를 반환하겠다.]
// * 참고 = new 명령문은 인스턴스를 생성하고 할당된 메모리 위치 정보를 반환해줌.
```

만약 참조변수에 null을 대입해버리면 참조변수는 인스턴스의 주소 값을 잃어버리게 되고, 이를 **참조가 끊겼다.** 고 함.  
참조가 끊긴 인스턴스는 더 이상 사용할 수 없음. = 쓰레기  
이렇게 쓰레기가 된 인스턴스들은 JVM의 **'가비지 콜렉션(Garbage Collection)'** 에 의해 메모리에서 삭제됨.  
메모리가 부족한 상황에서 JVM이 더 이상 사용하지 않는 객체들을 제거하는데, 이러한 작업을 **'가비지 콜렉션(Garbage Collection)'** 라고 함.


&nbsp;  
---
### ▷ 정적 멤버 선언
어떤 클래스로 만든 인스턴스들이 모두 공유하는 멤버가 필요할 때, **정적 멤버(static member)** 를 사용하면 좋음.
특정 인스턴스만 사용하는 것이 아닌, 해당 클래스로 생성한 모든 인스턴스가 공유하는 것.

→ 사용하는 법
  : 그냥 static 붙이면 됨.

```
static int totalCount;  // static 정수형 변수

public static void print1() {
  System.out.println("hello");
}                       // static 메서드 선언

static {
  System.out.println("hi");
}                      // static 블록 선언
```

위와 같이 static 키워드를 붙여서 다양한 형태로 선언 가능.  

이러한 static을 붙인 정적 멤버들은 프로그램이 시작될 때 딱 한 번 메모리의 코드 영역에 할당되며, 프로그램이 종료될 때까지 유지됨.  

1. **인스턴스**  /  인스턴스 생성 시  /  힙 메모리에 할당  /  인스턴스 소멸 시 메모리 해제
2. **클래스**  /  프로그램 시작 시  /  코드 메모리에 할당  /  프로그램 종료 시 메모리 해제
3. **static member**  /  프로그램 시작 시  /  코드 메모리에 할당  /  프로그램 종료 시 메모리 해제

JVM의 클래스 로더는 **main() 메서드가 시작되기 전** 에 로딩된 모든 클래스 코드를 살펴보고, static으로 선언된 정적 멤버를 메모리의 코드 영역에 할당함.  

```
class Count {
  public static int totalCount;    // totalCount 라는 정수형 변수 정적 멤버를 만듦. 얘는 코드 영역에 저장됨.
  int count;
}

public class CountTest {
  public static void main(String[] args) {
    Count c1 = new Count();        // Count 라는 인스턴스를 힙 영역에 만들고, 스택 영역의 c1 이라는 참조변수가 Count의 주소를 저장함.
}
```
이때 메모리를 보면,  
1. 스택 영역 = c1(참조변수)
2. 힙 영역 = Count 인스턴스 (count 라는 필드를 가짐. **totalCount는 코드 영역에 이미 할당되었으므로 힙 영역에는 X**)
3. 코드 영역 = Count 클래스와 그 클래스 안의 정적 멤버인 totalCount

Count라는 인스턴스가 생성되면, static인 totalCount는 힙 메모리에 할당되지 않고, 코드 영역에 할당된 클래스 필드의 정보를 포함함.  
 => static으로 선언한 필드를 **"클래스 필드"**, 그렇지 않은 필드를 **"인스턴스 필드"** 라고 함.  


#### ▷ 클래스 필드의 사용
클래스 필드는 참조변수가 필요 없음.  
  => main() 메서드 실행 전에 이미 코드 메모리에 생성되어있기 때문.  
객체 생성 없이 바로 *클래스명.필드명* 으로 접근 가능.  

