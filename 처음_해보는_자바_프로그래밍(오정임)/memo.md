# 개념 정리


***


### Q. IntelliJ 에서 out 파일은 뭔가요?
### A.
✅ out 폴더는 .java 파일을 컴파일해서 만들어진 .class 파일들이 저장되는 곳이다.  
우리가 작성하는 것 → .java (소스 코드)  
자바가 실행하는 것 → .class (바이트코드)  
그 .class가 모이는 곳 → ✅ out 폴더

&nbsp;
***  


### ▶ IntelliJ에서 실행 시 일어나는 과정 
javac Main.java  →  Main.class 생성  →  out 폴더에 저장  →  실행  

&nbsp;
***


### ★ 클래스, 인스턴스, 객체 정리 
클래스 class = 설계도  
인스턴스 instance = 클래스를 new 명령문으로 메모리에 생성한 객체  
객체 object = 클래스가 전산화된, 속성과 행동으로 구성되어 있는 실체  
new 클래스명(); 를 통해 메모리에 객체를 생성 = 인스턴스화 하다.  

```java
class Test { ... }
new Test();
new Test();
new Test();
//     -> 메모리에 Test 클래스의 인스턴스를 3개 생성함.
```


### ▷ 객체와 인스턴스의 차이?  
  → 둘 다 비슷하지만, 더 정확하게는  
**객체(Object)** : 클래스에서 만들어진 대상   ( **개념적 표현** ) 
**인스턴스(Instance)** : 메모리에 실제로 생성된 객체 ( **기술적 표현** )
객체가 더 큰 개념이다? (X) 똑같은데 표현만 좀 다른거.  

*" new 명령어를 한 번 써서 클래스를 인스턴스화 하면 객체가 생성되고, 메모리에 인스턴스가 하나 생긴다. "*  


&nbsp;
---

### ▶ JVM이 사용하는 JAVA의 메모리 구조  

Code 영역 / Heap 영역 / Stack 영역  

**코드(Code) 영역**은 메서드 영역이라고도 함.  
자바 실행 파일이 실행되는 구조임.  
test.java(소스 파일) → test.class(실행 파일) → JVM [ Class loder → Byte code verifier → Interpreter → Runtime System ] → 운영 체제 & HW  
&nbsp;


**힙(Heap) 영역**은, new 명령문 실행 시 클래스의 인스턴스가 생성되는 메모리 부분.  
참고로 인스턴스의 메서드는 코드 실행 시 Class loder에 의해 이미 생성되기 때문에, 실제로 힙 영역에 저장되는 것은 인스턴스의 필드 값임.  
메서드는 코드 영역에 생성된 내용을 사용함.  

힙 영역에 필드가 생성되면 자동으로 필드는 초기화 됨.  
```java
// 필드 타입별 초깃값
byte = 0
short = 0
int = 0
long = 0L
float = 0.0F
double = 0.0D
char = '\u0000'
boolean = false
모든 참조변수 = NULL
```
&nbsp;  

**스택(Stack) 영역**은 메서드의 매개변수와 같은 지역변수를 저장하는 메모리 부분.  
```java
public int sum(int data1, int data2) {
  int result = data1 + data2;
  return result
}
```
위와 같은 코드가 있고, sum(10,20); 을 호출했다고 가정한다면 다음과 같이 작동함.  
1. sum() 메서드 본문이 실행되기 전에 data1, data2 매개변수가 스택 영역에 생성되고, 각각 10, 20이 저장됨.
2. 메서드 본문이 실행되면 int 타입의 result 지역변수가 스택에 생성되고, data1 + data2 값으로 초기화 됨.
3. result 값 리턴.

매개변수(지역변수)가 스택에 생성되는 시점 = **메서드가 호출되어 실행될 때**  
매개변수(지역변수)가 스택에서 삭제되는 시점 = **메서드가 종료될 때**  
**" 그렇기 때문에 매개변수는 메서드 내에서만 사용할 수 있다! "**  
&nbsp;  


자바 프로그램이 직접 접근할 수 있는 메모리는 오직 **스택 밖에 없음.**  
힙 영역에 있는 필드 값에 곧바로 접근할 수 없기 때문에, 스택 메모리에 참조변수를 선언하고 이 변수에 힙 메모리에 생성된 인스턴스의 위치 정보(참조 정보)를 저장함.  
이게 명령문에서 어떤 식으로 나타나냐면,  
```java
클래스명 참조변수명 = new 클래스명();
// [데이터 타입 = (클래스명) 타입이다.] [스택 메모리에 생성될 참조변수의 이름]
// = [힙 메모리에 (클래스명) 인스턴스를 생성하고, 할당된 메모리의 위치 정보(참조 정보)를 반환하겠다.]
// * 참고 = new 명령문은 인스턴스를 생성하고 할당된 메모리 위치 정보를 반환해줌.
```


&nbsp;  
---


